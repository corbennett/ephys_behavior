# -*- coding: utf-8 -*-
"""
Created on Sat Sep 12 15:52:39 2020

@author: svc_ccg
"""

import os
import numpy as np
import pandas as pd
import matplotlib
matplotlib.rcParams['pdf.fonttype']=42
import matplotlib.pyplot as plt
from sync import sync
import ecephys


base_data_dir = r"Z:\NpxUltra\509812_09142020"
syncFile = r"Z:\NpxUltra\509812_09142020\509812_sync_400um_200914152822.h5"
probeLabel = 'C'
probeDataDir = r"Z:\NpxUltra\509812_09142020\2020-09-14_15-28-24_ABC_400um"
optoPklFile = r"Z:\NpxUltra\509812_09142020\200914154851_366122.opto_400um.pkl"

def get_sync_line_data(syncDataset, line_label=None, channel=None):
    ''' Get rising and falling edge times for a particular line from the sync h5 file
        
        Parameters
        ----------
        dataset: sync file dataset generated by sync.Dataset
        line_label: string specifying which line to read, if that line was labelled during acquisition
        channel: integer specifying which channel to read in line wasn't labelled
        
        Returns
        ----------
        rising: npy array with rising edge times for specified line
        falling: falling edge times
    '''
    if isinstance(line_label, str):
        try:
            channel = syncDataset.line_labels.index(line_label)
        except:
            print('Invalid line label')
            return
    elif channel is None:
        print('Must specify either line label or channel id')
        return
    
    sample_freq = syncDataset.meta_data['ni_daq']['counter_output_freq']
    rising = syncDataset.get_rising_edges(channel)/sample_freq
    falling = syncDataset.get_falling_edges(channel)/sample_freq
    
    return rising, falling


def getPSTH(spikes,startTimes,windowDur,binSize=0.01,avg=True):
    bins = np.arange(0,windowDur+binSize,binSize)
    counts = np.zeros((len(startTimes),bins.size-1))    
    for i,start in enumerate(startTimes):
        counts[i] = np.histogram(spikes[(spikes>=start) & (spikes<=start+windowDur)]-start,bins)[0]
    if avg:
        counts = counts.mean(axis=0)
    counts /= binSize
    t = bins[:-1]
    return counts,t



pxiDict = {'A': 'slot2-probe1',
           'B': 'slot2-probe2',
           'C': 'slot2-probe3',
           'D': 'slot3-probe1',
           'E': 'slot3-probe2',
           'F': 'slot3-probe3'}

nChannels = 384
probeCols = 8
probeRows = 48
channelSpacing = 6 # microns
probeX = np.arange(probeCols)*channelSpacing
probeY = np.arange(probeRows)*channelSpacing


# raw spike data
probeSpikeDataDir = os.path.join(probeDataDir,'continuous','Neuropix-PXI-'+pxiDict[probeLabel]+'-AP')
rawData = np.memmap(os.path.join(probeSpikeDataDir,'continuous.dat'),dtype='int16',mode='r')    
rawData = np.reshape(rawData,(int(rawData.size/nChannels),-1)).T
totalSamples = rawData.shape[1]


#fig = plt.figure(figsize=(10,10))
#gs = matplotlib.gridspec.GridSpec(probeRows,probeCols)
#data = rawData[:,:30000]
#ymin = data.min()
#ymax = data.max()
#j = 0
#for ch,d in enumerate(data):
#    i = probeRows-1-ch//probeCols
#    ax = fig.add_subplot(gs[i,j])
#    if j==7:
#        j = 0
#    else:
#        j += 1
#    ax.plot(d,'k')
#    for side in ('right','top','left','bottom'):
#        ax.spines[side].set_visible(False)
#    ax.set_xticks([])
#    ax.set_yticks([])
#    ax.set_ylim([ymin,ymax])
#plt.tight_layout()


probeMean = np.zeros((probeRows,probeCols))
probeStd = np.zeros((probeRows,probeCols))
j = 0
for ch,d in enumerate(rawData[:,:300000]):
    i = ch//probeCols
    probeMean[i,j] = d.mean()
    probeStd[i,j] = d.std()
    if j==7:
        j = 0
    else:
        j += 1

fig = plt.figure(figsize=(3,10))
ax = fig.add_subplot(2,1,1)
im = ax.imshow(probeMean,cmap='gray')
cb = plt.colorbar(im,ax=ax,fraction=0.05,pad=0.04,shrink=0.5)
ax.set_title('raw mean')
ax = fig.add_subplot(2,1,2)
im = ax.imshow(probeStd,cmap='gray')
cb = plt.colorbar(im,ax=ax,fraction=0.05,pad=0.04,shrink=0.5)
ax.set_title('raw std')
plt.tight_layout()


fig = plt.figure(figsize=(10,10))
channelsToPlot = [219,220]
samplesToPlot = slice(12000,22000)
ymin = rawData[channelsToPlot,samplesToPlot].min()
ymax = rawData[channelsToPlot,samplesToPlot].max()
for i,ch in enumerate(channelsToPlot):
    ax = fig.add_subplot(len(channelsToPlot),1,i+1)
    ax.plot(rawData[ch,samplesToPlot],'k')
    for side in ('right','top'):
        ax.spines[side].set_visible(False)
    ax.set_ylim([ymin,ymax])
    ax.set_ylabel('uV')
    if i==len(channelsToPlot)-1:
        ax.set_xlabel('Sample')
    ax.set_title('ch '+str(ch))
plt.tight_layout()



# sync data
syncDataset = sync.Dataset(syncFile)

probeEventsDir = os.path.join(os.path.join(probeDataDir,'events','Neuropix-PXI-'+pxiDict[probeLabel]),'TTL_1')
    
# get barcodes from sync file
bRising, bFalling = get_sync_line_data(syncDataset, 'barcode')
bs_t, bs = ecephys.extract_barcodes_from_times(bRising, bFalling)

# get barcodes from ephys data
channel_states = np.load(os.path.join(probeEventsDir,'channel_states.npy'))
event_times = np.load(os.path.join(probeEventsDir,'event_timestamps.npy'))

beRising = event_times[channel_states>0]/30000.
beFalling = event_times[channel_states<0]/30000.
be_t, be = ecephys.extract_barcodes_from_times(beRising, beFalling)
    
# compute time shift between ephys and sync
probeShift, probeSampleRate, m_endpoints = ecephys.get_probe_time_offset(bs_t, bs, be_t, be, 0, 30000)



# unit data
kilosortData = {key: np.load(os.path.join(probeSpikeDataDir,key+'.npy')) for key in ('spike_clusters',
                                                                                     'spike_times',
                                                                                     'templates',
                                                                                     'spike_templates',
                                                                                     'channel_positions',
                                                                                     'amplitudes')}

clusterIDs = pd.read_csv(os.path.join(probeSpikeDataDir,'cluster_KSLabel.tsv'),sep='\t')

unitIDs = np.unique(kilosortData['spike_clusters'])

unitData = {}
for u in unitIDs:
    unitData[u] = {}
    unitData[u]['label'] = clusterIDs[clusterIDs['cluster_id']==u]['KSLabel'].tolist()[0]
    
    uind = np.where(kilosortData['spike_clusters']==u)[0]
    
    unitData[u]['spikeTimes'] = kilosortData['spike_times'][uind]/probeSampleRate-probeShift
    
    unitData[u]['spikeRate'] = unitData[u]['spikeTimes'].size/totalSamples*probeSampleRate
    
    #choose 1000 spikes with replacement, then average their templates together
    chosen_spikes = np.random.choice(uind,1000)
    chosen_templates = kilosortData['spike_templates'][chosen_spikes].flatten()
    unitData[u]['template'] = np.mean(kilosortData['templates'][chosen_templates],axis=0).T
    
    peakChan = np.unravel_index(np.argmin(unitData[u]['template']),unitData[u]['template'].shape)[0]
    unitData[u]['peakChan'] = peakChan
    unitData[u]['position'] = kilosortData['channel_positions'][peakChan]
    unitData[u]['amplitudes'] = kilosortData['amplitudes'][uind]
    
    peakTemplate = unitData[u]['template'][peakChan]
    if any(np.isnan(peakTemplate)):
        unitData[u]['peakToTrough'] = np.nan
    else:
        peakInd = np.argmin(peakTemplate)
        unitData[u]['peakToTrough'] = np.argmax(peakTemplate[peakInd:])/(probeSampleRate/1000)
    
    #check if this unit is noise
    tempNorm = peakTemplate/np.max(np.absolute(peakTemplate))
    unitData[u]['normTempIntegral'] = tempNorm.sum()
    if abs(tempNorm.sum())>4:
        unitData[u]['label'] = 'noise'

goodUnits = np.array([u for u in unitData if unitData[u]['label']=='good' and unitData[u]['spikeRate']>0.1])
goodUnits = goodUnits[np.argsort([unitData[u]['peakChan'] for u in goodUnits])]



# plot templates
for u in goodUnits:
    fig = plt.figure(figsize=(10,10))
    gs = matplotlib.gridspec.GridSpec(probeRows,probeCols)
    template = unitData[u]['template']
    ymin = template.min()
    ymax = template.max()
    for ind,ch in enumerate(template):
        chX,chY = kilosortData['channel_positions'][ind]
        i = probeRows-1-np.where(probeY==chY)[0][0]
        j = np.where(probeX==chX)[0][0]
        ax = fig.add_subplot(gs[i,j])
        clr = 'r' if ind==unitData[u]['peakChan'] else 'k'
        ax.plot(ch,color=clr,lw=2)
        for side in ('right','top','left','bottom'):
            ax.spines[side].set_visible(False)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_xlim([31,52])
        ax.set_ylim([ymin,ymax])
    plt.tight_layout()


for u in [16]:#goodUnits:
    templateAmp = np.zeros((probeRows,probeCols))
    for ind,ch in enumerate(unitData[u]['template']):
        chX,chY = kilosortData['channel_positions'][ind]
        i = probeRows-1-np.where(probeY==chY)[0][0]
        j = np.where(probeX==chX)[0][0]
        templateAmp[i,j] = ch.min()
        
    fig = plt.figure(figsize=(6,8))
    ax = fig.add_subplot(1,1,1)
    im = ax.imshow(templateAmp,cmap='gray')
    cb = plt.colorbar(im,ax=ax,fraction=0.05,pad=0.04,shrink=0.5)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_title('template amplitude')
    plt.tight_layout()
    


# optotagging 
optoPklData = pd.read_pickle(optoPklFile)

optoSampleRate = 5000

optoOnTimes,optoOffTimes = get_sync_line_data(syncDataset,'opto_stim')

optoConditions = np.unique(optoPklData['opto_conditions'])
optoLevels = np.unique(optoPklData['opto_levels'])
cmap = np.ones((len(optoLevels),3))
cmap[:,:2] = np.arange(0,1.01-1/len(optoLevels),1/len(optoLevels))[::-1,None]
preTime = 0.5
windowDur = 2
for u in [16]:#goodUnits:
    fig = plt.figure(figsize=(8,8))
    gs = matplotlib.gridspec.GridSpec(2,len(optoConditions))
    for j,condition in enumerate(optoConditions):
        ax = fig.add_subplot(gs[0,j])
        waveform = optoPklData['opto_waveforms'][condition]
        wf = np.zeros(int(windowDur*optoSampleRate))
        preSamples = int(preTime*optoSampleRate)
        wf[preSamples:preSamples+waveform.size] = waveform
        t = np.arange(0,windowDur,1/optoSampleRate)-preTime
        ax.plot(t,wf,'k')
        ax.set_xlim([-preTime,windowDur-preTime])
        ax.set_ylabel('Stimulus level (normalized)')
        
        ax = fig.add_subplot(gs[1,j])
        for level,clr in zip(optoLevels,cmap):
            optoTrials = (optoPklData['opto_conditions']==condition) & (optoPklData['opto_levels']==level)
            psth,t = getPSTH(unitData[u]['spikeTimes'],optoOnTimes[optoTrials]-preTime,windowDur,binSize=0.01)
            ax.plot(t-preTime,psth,color=clr,label=str(level)+' V')
        for side in ('right','top'):
            ax.spines[side].set_visible(False)
        ax.tick_params(direction='out',top=False,right=False)
        ax.set_xlim([-preTime,windowDur-preTime])
        ax.set_xlabel('Time from opto onset (s)')
        ax.set_ylabel('Spikes/s')
        ax.legend()     
    plt.tight_layout()



